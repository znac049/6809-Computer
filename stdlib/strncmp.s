* 6809 assembly program generated by cmoc 0.1.86


	SECTION	code


___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_bsearch	IMPORT
_cmpdww	IMPORT
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enable_printf_float	IMPORT
_exit	IMPORT
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_labs	IMPORT
_ltoa10	IMPORT
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readline	IMPORT
_readword	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_setConsoleOutHook	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_strcspn	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncpy	IMPORT
_strpbrk	IMPORT
_strrchr	IMPORT
_strspn	IMPORT
_strstr	IMPORT
_strtok	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_ultoa10	IMPORT
_utoa10	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_zerodw	IMPORT
_strncmp	EXPORT


*******************************************************************************

* FUNCTION strncmp(): defined at strncmp.c:5
_strncmp	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-2,S
* Formal parameter(s):
*      4,U:    2 bytes: s1: const char *: line 5
*      6,U:    2 bytes: s2: const char *: line 5
*      8,U:    2 bytes: n: unsigned int: line 5
* Local non-static variable(s):
*     -2,U:    2 bytes: diff: int: line 9
	BRA	L00079		jump to for condition
L00078	EQU	*
* Line strncmp.c:8: for body
* Line strncmp.c:9: init of variable diff
	LDB	[6,U]		indirection
* Cast from `const char' to byte: result already in B
	CLRA			cast from byte
	PSHS	B,A
	LDB	[4,U]		indirection
* Cast from `const char' to byte: result already in B
* optim: stripExtraClrA_B
	SUBD	,S++
	STD	-2,U		variable diff
* Line strncmp.c:10: if
* optim: storeLoad
* optim: loadCmpZeroBeqOrBne
	BEQ	L00083		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00082 removed
* Line strncmp.c:11
* Line strncmp.c:11: return with value
	LDD	-2,U		variable `diff', declared at strncmp.c:9
	BRA	L00077		return (strncmp.c:11)
L00083	EQU	*		else clause of if() started at strncmp.c:10
* Useless label L00084 removed
* Useless label L00080 removed
* Line strncmp.c:7: for increment(s)
	LDD	8,U		variable `n', declared at strncmp.c:7
	ADDD	#-1
	STD	8,U
	LDD	4,U		variable `s1', declared at strncmp.c:7
	ADDD	#1
	STD	4,U
	LDD	6,U		variable `s2', declared at strncmp.c:7
	ADDD	#1
	STD	6,U
L00079	EQU	*
* Line strncmp.c:7: for condition
	LDD	8,U		variable n
* optim: removeCMPZeroAfterLDIfBHI (BHI->BNE)
	BEQ	L00081		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00086 removed
	LDB	[4,U]		indirection
* optim: loadCmpZeroBeqOrBne
	BEQ	L00081		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00085 removed
	LDB	[6,U]		indirection
* optim: loadCmpZeroBeqOrBne
	BNE	L00078
* optim: branchToNextLocation
L00081	EQU	*		end for
* Line strncmp.c:13: if
	LDD	8,U		variable `n', declared at strncmp.c:5
* optim: loadCmpZeroBeqOrBne
	BNE	L00088		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00087 removed
* Line strncmp.c:14
* Line strncmp.c:14: return with value
	CLRA
	CLRB
	BRA	L00077		return (strncmp.c:14)
L00088	EQU	*		else clause of if() started at strncmp.c:13
* Useless label L00089 removed
* Line strncmp.c:15: if
	LDB	[4,U]		indirection
* optim: loadCmpZeroBeqOrBne
	BNE	L00091
* optim: branchToNextLocation
* Useless label L00090 removed
* Line strncmp.c:16
* Line strncmp.c:16: return with value
* Line strncmp.c:16: conditional expression
	LDB	[6,U]		indirection
* optim: loadCmpZeroBeqOrBne
	BEQ	L00093		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00092 removed
	LDD	#$FFFF		constant expression: 65535 decimal, signed
	BRA	L00094		end of true expression of conditional
L00093	EQU	*
	CLRA
	CLRB
L00094	EQU	*
	SEX			cast from byte
	BRA	L00077		return (strncmp.c:16)
L00091	EQU	*		else clause of if() started at strncmp.c:15
* Useless label L00095 removed
* Line strncmp.c:18: return with value
	CLRA
	LDB	#$01		constant expression: 1 decimal, signed
* optim: branchToNextLocation
L00077	EQU	*		end of strncmp()
	LEAS	,U
	PULS	U,PC
* END FUNCTION strncmp(): defined at strncmp.c:5
funcend_strncmp	EQU *
funcsize_strncmp	EQU	funcend_strncmp-_strncmp


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*
string_literals_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
* Uninitialized local static variables
bss_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 0 utility routine(s).


*******************************************************************************

	END
